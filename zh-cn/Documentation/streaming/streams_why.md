---
layout: page
title: Why Orleans Streams?
---

# 为什么是OrleansStreams？

已经有很多技术可以让你构建流处理系统。这些系统包括**持久存储流数据**(例如。，[活动中心](http://azure.microsoft.com/en-us/services/event-hubs/)和[卡夫卡](http://kafka.apache.org/))以及要表达的系统**计算操作**过流数据(例如。，[Azure流分析](http://azure.microsoft.com/en-us/services/stream-analytics/), [阿帕奇风暴](https://storm.apache.org/)，和[Apache Spark流媒体](https://spark.apache.org/streaming/)). 这些都是很好的系统，允许您构建高效的数据流处理管道。

### 现有系统的局限性

但是，这些系统不适合**细Grain自由格式流上计算数据**. 上面提到的流计算系统都允许您指定**以相同方式应用于所有流项目的操作的统一数据流图**. 当数据是统一的，并且您希望对这些数据表示相同的转换、过滤或聚合操作时，这是一个功能强大的模型。但是还有一些用例需要在不同的数据项上表达根本不同的操作。在其中一些应用程序中，作为处理的一部分，您有时需要进行外部调用，例如调用任意restapi。统一数据流处理引擎要么不支持这些场景，要么以有限和受限的方式支持它们，要么效率低下。这是因为它们天生就针对**大量类似的物品，通常在表现力、加工方面受到限制**. OrleansStreams针对的是其他场景。

### 动机

这一切都是从Orleans用户请求支持从grain方法调用返回项目序列开始的。你可以想象，这只是冰山一角。他们实际上需要的远不止这些。

Orleans Streams的一个典型场景是当您有每个用户的流并且您希望执行**每个用户的不同处理**，在单个用户的上下文中。我们可能有数百万用户，但他们中的一些人对天气感兴趣，可以订阅特定地点的天气预报，而有些人则对体育赛事感兴趣；还有人在跟踪某一航班的状态。处理这些事件需要不同的逻辑，但您不希望运行流处理的两个独立实例。一些用户只对特定的股票感兴趣，而且只有在应用某个外部条件时才感兴趣，这种情况可能不一定是流数据的一部分(因此需要在运行时作为处理的一部分进行动态检查)。

用户一直在改变他们的兴趣，因此他们对特定事件流的订阅是动态的，因此**流媒体的拓扑结构动态而快速地变化**. 除此之外，**每个用户的处理逻辑也会根据用户状态和外部事件动态地演化和更改**. 外部事件可以修改特定用户的处理逻辑。例如，在一个游戏作弊检测系统中，当发现一种新的作弊方式时，需要用新规则更新处理逻辑来检测这种新的违规行为。这当然需要做**不会中断正在进行的处理管道**. 批量数据流处理引擎并不是为了支持这样的场景而构建的。

几乎不用说，这样的系统必须运行在多台网络连接的机器上，而不是在一个节点上。因此，处理逻辑必须以可伸缩和弹性的方式分布在服务器集群上。

### 新要求

我们确定了流处理系统的4个基本需求，这将使它能够针对上述场景。

1.  灵活的流处理逻辑
2.  支持高度动态的拓扑
3.  细Grain流Grain
4.  分配

#### 灵活的流处理逻辑

我们希望系统支持不同的方式来表达流处理逻辑。我们上面提到的现有系统要求开发人员编写一个声明性的数据流计算图，通常是遵循函数式编程风格。这限制了处理逻辑的表达能力和灵活性。Orleans流与处理逻辑的表达方式无关。它可以表示为一个数据流(例如，使用[NET中的无功扩展(Rx)](https://msdn.microsoft.com/en-us/data/gg577609.aspx))；作为一个函数程序；作为一个声明性查询；或者在一般的命令逻辑中。逻辑可以是有状态的或无状态的，可能有副作用，也可能没有副作用，并且可以触发外部操作。所有的权力都属于开发者。

#### 支持动态拓扑

我们希望系统能够支持动态演化的拓扑结构。我们上面提到的现有系统通常仅限于静态拓扑，这些拓扑在部署时是固定的，并且不能在运行时演化。在下面的数据流表达式示例中，在需要更改之前，一切都很简单。

`流.GroupBy(x=>x.key)。提取(x=>x.field)。选择(x=>x+2)。平均窗口(x，5秒)。其中(x=>x>0.8)*`

在中更改阈值条件`在哪里？`过滤器，添加额外的`选择`语句或在数据流图中添加另一个分支并生成新的输出流。在现有系统中，如果不拆除整个拓扑结构并从头开始重新启动数据流，这是不可能的。实际上，这些系统将检查现有的计算，并将能够从最新的检查点重新启动。尽管如此，这样的重新启动对于一个实时产生结果的在线服务来说是破坏性的和昂贵的。当我们在讨论大量这样的表达式时，这种重新启动变得特别不切实际，这些表达式使用相似但不同的(每个用户、每个设备等)参数执行，并且这些参数不断变化。

我们希望系统允许在运行时通过向计算图中添加新的链接或节点，或通过更改计算节点内的处理逻辑来进化流处理图。

#### 细Grain流Grain

在现有系统中，最小的抽象单元通常是整个流(拓扑)。然而，我们的许多目标场景要求拓扑中的单个节点/链路本身就是一个逻辑实体。这样每个实体都可以独立管理。例如，在包含多个链路的大流拓扑中，不同的链路可以具有不同的特性，并且可以在不同的物理传输上实现。一些链接可以通过TCP套接字，而其他链接可以通过可靠队列。不同的链接可以有不同的交付保证。不同的节点可以有不同的检查点策略，它们的处理逻辑可以用不同的模型甚至不同的语言来表达。这种灵活性在现有系统中通常是不可能的。

抽象单元和灵活性的论据类似于SoA(面向服务的体系结构)与参与者的比较。Actor系统允许更大的灵活性，因为每个Actor本质上都是一个独立管理的“微型服务”。类似地，我们希望流系统允许这种细Grain的控制。

#### 分配

当然，我们的系统应该具有**“良好的分布式系统”**. 其中包括：

1.  *可扩展性*-支持大量流和计算元素。
2.  *弹性*-允许添加/删除资源以根据负载增长/收缩。
3.  *可靠性*-对失败有弹性
4.  *效率*-有效利用底层资源
5.  *响应性*-启用近实时场景。

这些都是我们在考虑建造的要求[**Orleans流媒体**](index.md).

* * *

*澄清*：Orleans当前不支持像上面的示例那样直接编写声明性数据流表达式。如前所述，当前的Orleans流媒体api是更低级的构建块[在这里](streams_programming_APIs.md). 提供声明性的数据流表达式是我们未来的目标。

## 下一个

[Orleans流编程API](streams_programming_APIs.md)
