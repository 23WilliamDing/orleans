---
layout: page
title: Frequently Asked Questions
---

[//]: # "TODO: after files are rearranged and checked for accuracy, put links back"

# 常见问题解答

## 可利用性

### 我可以在我的项目中免费使用Orleans吗？

当然。源代码已经在[麻省理工学院执照](https://github.com/dotnet/orleans/blob/master/LICENSE). NuGet包发布于[nuget.org网站](https://www.nuget.org/profiles/Orleans).

### Orleans的生产准备好了吗？我听说这是一个研究项目。

实际上，Orleans最初是作为微软研究院的一个研究项目开始的。它后来成长为一种产品，自2011年起在微软内部投入生产，并在2015年公开发布后被其他公司使用。Orleans已经做好了生产准备，为许多高可用性系统和云服务提供了动力。

### 微软支持Orleans吗？

Orleans的源代码已经在麻省理工学院授权下发布[GitHub](https://github.com/dotnet/orleans). 微软继续在Orleans投资，并接受社区对代码库的贡献。

## 定位

### Orleans是服务器产品吗？我如何管理Orleans？

Orleans是一个框架，一组库，可以帮助您构建应用程序。基于Orleans的应用程序可以在各种托管环境中运行，在云端或本地集群中，甚至在一台机器上。应用程序开发人员负责在其目标宿主环境中构建、部署和运行基于Orleans的应用程序。

### 我在哪里可以跑Orleans？

Orleans可以在任何.NET应用程序可以运行的环境中运行。在Orleans 2.0之前，它需要完整的.NET框架。从2.0开始，Orleans遵循.NET标准2.0，因此可以在支持.NETCore的Windows和非Windows环境中运行.NETCore。

### Orleans是为蔚蓝而建的吗？

不，我们相信你应该可以在任何你需要的地方，以你需要的方式管理Orleans。Orleans非常灵活，并且有许多可选的提供商帮助在云环境中托管它，比如Azure、AWS或GCP，或者本地集群，可以选择支持Orleans集群协议的技术。

### Orleans和其他actor语言和框架（比如Erlang或Akka）有什么区别？

虽然基于Actor模型的相同基本原则，但Orleans向前迈进了一步，引入了虚拟参与者的概念，该概念极大地简化了开发人员的体验，并且更适合于云服务和高规模系统。

## 设计

### 在我的应用程序中，Grains应该有多大或多小？

grains隔离模型使它们能够很好地表示独立的状态和计算上下文。在大多数情况下，grains自然地映射到用户、会话、帐户等应用程序实体。这些实体通常彼此隔离，可以独立访问和更新，并公开一组定义良好的受支持操作。这与直观的“一个实体-一个纹理”模型很好地配合使用。

如果一个应用程序实体封装了太多的状态，那么它可能太大，无法用单个grains有效地表示，因此必须处理对它的高速率请求。尽管一个单独的grain通常每秒可以处理几千个琐碎的调用，但经验法则是要警惕单个grain每秒接收数百个请求。这可能是Grains太大的迹象，将其分解成一组更小的grains可能会导致一个更稳定和平衡的系统。

一个应用程序实体可能太小而不能成为一个粒度，如果这会导致其他粒度与之持续交互，并因此导致太多的消息传递开销。在这种情况下，让那些相互作用密切的实体成为单个grains的一部分，这样它们就可以直接相互调用了。

### 如何避免grain热点？

Grains的吞吐量受单个线程的限制，该线程的激活可以在该线程上执行。因此，建议避免一个单独的粒度接收到不相称的请求份额或参与处理对其他粒度的请求的设计。有多种模式可以帮助防止单个grains过载，即使在逻辑上它是通信的中心点。

例如，如果一个grain是由大量grain定期报告的一些计数器或统计信息的聚合器，一种行之有效的方法是添加控制数量的中间聚合器粒度，并将每个报告粒度（使用键上的模或散列）分配给中间聚合器，以便负载或多或少地均匀分布在所有中间聚集grains上，这些中间聚集grains定期向中央聚集grains报告部分聚集物。

## 如何

### 我怎样才能撕下一粒Grains？

一般来说，不需要应用程序逻辑来强制取消激活grain，因为Orleans运行时会自动检测并停用grain的空闲激活以回收系统资源。让Orleans这样做更有效，因为它批处理停用操作，而不是逐个执行它们。在极少数情况下，当您认为确实需要加快grains的失活，可以通过调用`base.DeactivateOnIdle()`方法。

### 我能告诉Orleans在哪里激活Grains吗？

使用限制性的布局策略是可以做到的，但我们通常认为这是一种非常先进的模式，需要仔细考虑。通过按照问题的建议来做，应用程序将承担资源管理的负担，而不一定要有足够的关于系统全局状态的信息来做到这一点。在silos重启的情况下，这种情况尤其适得其反，在云环境中，操作系统补丁可能会定期发生这种情况。因此，特定位置可能会对应用程序的可伸缩性以及对系统故障的恢复能力产生负面影响。

也就是说，对于应用程序确实知道应该在何处激活特定grains的罕见情况，例如，如果它知道grain持久状态的位置，那么在1.5.0中，我们引入了自定义存储策略和控制器。

### 如何对grains进行版本设置或添加新的grain类和接口？

您可以向正在运行的集群中添加具有新粒度类或现有粒度类的新版本的silos。

### 我能从公共互联网连接到Orleans的发射井吗？

Orleans被设计为作为服务的后端部分进行托管，您需要创建一个外部客户端将连接到的前端层。它可以是基于HTTP的webapi项目、socket服务器、signal服务器或其他任何适合应用程序需要的服务器。如果您将竖井的TCP端点暴露给它，您可以从Internet连接到Orleans，但是从安全性的角度来看，这不是一个好的实践。

### 如果在我的Grains调用返回对我的调用的响应之前发生故障，会发生什么情况？

如果在grain调用过程中发生silos故障，您将收到一个异常，您可以在代码中捕获并重试，或者根据应用程序逻辑执行其他操作来处理错误。在silos中失败的Grains将在下次调用时自动重新实例化。Orleans运行时并不急于从一个失败的silos中重新创建Grains，因为它们中的许多可能不是立即需要的，或者根本就不需要。相反，运行时会单独地重新创建这些粒度，并且只有在针对特定粒度的新请求到达时。对于每一粒Grains，它从一个可用的silos中挑选一个作为新的寄主。

这种方法的好处是，回收过程只对实际使用的Grains执行，而且它会及时分布在所有可用的silos中，这提高了系统的响应能力和回收速度。还要注意，在silos发生故障和Orleans集群检测到故障之间存在延迟。延迟是检测速度和误报概率之间的可配置折衷。在此过渡期间，对Grains的所有调用都将失败，但在检测到故障后，将在另一个silos上创建一个新的Grains调用，因此它最终将可用。

### 如果Grains调用执行时间过长，会发生什么情况？

由于Orleans使用一个协作的多任务模型，它不会自动抢占grain的执行，但是Orleans会为长时间执行的grain调用生成警告，以便您可以检测到它们。与抢占式多任务相比，协作多任务具有更好的吞吐量。请记住，grain调用不应同步执行任何长时间运行的任务，如IO操作，也不应阻塞其他要完成的任务。所有等待都应该使用异步方式完成`等待`或其他异步关键字等待机制。Grains应该尽快返回，让其他Grains执行以获得最大吞吐量。
